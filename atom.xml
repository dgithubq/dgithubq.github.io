<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>芋泥の宝藏屋</title>
  
  <subtitle>dwhの博客</subtitle>
  <link href="https://dwhboke.com/atom.xml" rel="self"/>
  
  <link href="https://dwhboke.com/"/>
  <updated>2022-04-23T03:12:09.714Z</updated>
  <id>https://dwhboke.com/</id>
  
  <author>
    <name>dwh520dyn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Collections工具类</title>
    <link href="https://dwhboke.com/posts/16.html"/>
    <id>https://dwhboke.com/posts/16.html</id>
    <published>2022-04-23T03:09:00.000Z</published>
    <updated>2022-04-23T03:12:09.714Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h3><h4 id="Collections工具类的介绍"><a href="#Collections工具类的介绍" class="headerlink" title="Collections工具类的介绍"></a>Collections工具类的介绍</h4><ol><li><code>Collections</code>是一个操作Set、List和Map等集合的工具类</li><li><code>Collections</code>中提供了一系列的静态的方法对集合元素进行排序、查询和修改等操作</li></ol><h4 id="排序操作：（均为static方法）"><a href="#排序操作：（均为static方法）" class="headerlink" title="排序操作：（均为static方法）"></a>排序操作：（均为static方法）</h4><ol><li><code>reverse(List)</code>：反转List中元素的顺序</li><li><code>Shuffle(List)</code>：对List集合元素进行随机排序</li><li><code>sort(List)</code>：根据元素的自然顺序对指定List集合元素按升序排列</li><li><code>sort(List，Comparator)</code>：根据指定的Comparator产生的顺序对List集合元素进行排序</li><li><code>swap(List，int，int)</code>：将指定的list集合中的i处元素和j处元素进行交换</li></ol><h4 id="查找、替换操作"><a href="#查找、替换操作" class="headerlink" title="查找、替换操作"></a>查找、替换操作</h4><ol><li><code>Object max(Collection)</code>：根据元素的自然顺序，返回给定集合中最大的元素</li><li><code>Object max(Collection,Comparator)</code>：根据Comparator指定的顺序，返回给定集合中的最大元素</li><li><code>Object min(Collection)</code></li><li><code>Object min(Collection,Comparator)</code></li><li><code>int frequency(Collection,Object)</code>：返回指定集合中指定元素出现的次数</li><li><code>void copy(List dest,List src)</code>：将src中的内容复制到dest中</li><li><code>boolean replaceAll(List list,Object oldVal,Object newVal)</code>：使用新值替换List对象的所有旧值</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Collections工具类&quot;&gt;&lt;a href=&quot;#Collections工具类&quot; class=&quot;headerlink&quot; title=&quot;Collections工具类&quot;&gt;&lt;/a&gt;Collections工具类&lt;/h3&gt;&lt;h4 id=&quot;Collections工具类的介绍</summary>
      
    
    
    
    <category term="技术 学习 java 集合" scheme="https://dwhboke.com/categories/%E6%8A%80%E6%9C%AF-%E5%AD%A6%E4%B9%A0-java-%E9%9B%86%E5%90%88/"/>
    
    
    <category term="技术 操作 学习 集合" scheme="https://dwhboke.com/tags/%E6%8A%80%E6%9C%AF-%E6%93%8D%E4%BD%9C-%E5%AD%A6%E4%B9%A0-%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>总结-开发中如何选择集合实现类</title>
    <link href="https://dwhboke.com/posts/15.html"/>
    <id>https://dwhboke.com/posts/15.html</id>
    <published>2022-04-23T03:08:00.000Z</published>
    <updated>2022-04-23T03:08:36.030Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总结-开发中如何选择集合实现类"><a href="#总结-开发中如何选择集合实现类" class="headerlink" title="总结-开发中如何选择集合实现类"></a>总结-开发中如何选择集合实现类</h2><ol><li>先判断存储的类型（一组对象或者一组键值对）</li><li>一组对象：Collection接口<ol><li>允许重复：List<ol><li>增删多：LinkedList：因为底层维护了一个双向链表</li><li>改查多：ArrayList：底层维护了Object类型的可变数组</li></ol></li><li>不允许重复：Set<ol><li>无序：HashSet：底层是HashMap，维护了一个哈希表（数组+链表+红黑树）</li><li>排序：TreeSet</li><li>插入和取出一致：LinkedHashSet，维护数组+双向链表</li></ol></li></ol></li><li>一组键值对：Map接口<ol><li>键无序：HashMap：底层是哈希表 数组+链表+红黑树</li><li>键排序：TreeMap</li><li>键插入和取出一致：LinkedHashMap</li><li>读取文件：Properties</li></ol></li></ol><h4 id="集合关系图"><a href="#集合关系图" class="headerlink" title="集合关系图"></a>集合关系图</h4><p><img src="https://s2.loli.net/2022/04/23/pQemdzGD431L2EO.png"></p><p><img src="https://s2.loli.net/2022/04/23/ZwrMpxR8qOyXnCa.png"></p><p><img src="https://s2.loli.net/2022/04/23/gV6JZh3HIBEb8ku.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;总结-开发中如何选择集合实现类&quot;&gt;&lt;a href=&quot;#总结-开发中如何选择集合实现类&quot; class=&quot;headerlink&quot; title=&quot;总结-开发中如何选择集合实现类&quot;&gt;&lt;/a&gt;总结-开发中如何选择集合实现类&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;先判断存储的类型（一组对</summary>
      
    
    
    
    <category term="技术 学习 java 集合" scheme="https://dwhboke.com/categories/%E6%8A%80%E6%9C%AF-%E5%AD%A6%E4%B9%A0-java-%E9%9B%86%E5%90%88/"/>
    
    
    <category term="技术 操作 学习 集合" scheme="https://dwhboke.com/tags/%E6%8A%80%E6%9C%AF-%E6%93%8D%E4%BD%9C-%E5%AD%A6%E4%B9%A0-%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Map集合之Hashtable</title>
    <link href="https://dwhboke.com/posts/14.html"/>
    <id>https://dwhboke.com/posts/14.html</id>
    <published>2022-04-23T03:07:00.000Z</published>
    <updated>2022-04-23T03:07:25.945Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Hashtable类"><a href="#Hashtable类" class="headerlink" title="Hashtable类"></a>Hashtable类</h3><ol><li>存放的元素是键值对：K-V</li><li>hashtable的键和值都不能为null，否则会抛出NullPointerException</li><li>hashTable使用方法基本上和HashMap一样</li><li>hashTable是线程安全的（synchronized），hashMap是线程不安全的</li><li>底层有数组Hashtable$Entry[]，初始大小为11</li><li>临界值 threshold为：8 = 11*0.75</li><li>扩容是原先大小*2+1</li></ol><h4 id="Hashtable子类：Properties（与I-O流有关）"><a href="#Hashtable子类：Properties（与I-O流有关）" class="headerlink" title="Hashtable子类：Properties（与I/O流有关）"></a>Hashtable子类：Properties（与I/O流有关）</h4><ol><li>Properties继承自Hashtable类并且实现了Map接口，也是使用一种键值对的形式来保存数据</li><li>它的使用特点和Hashtable类似</li><li>Properties还可以用于从xxx.properties文件中，加载数据到Properties类对象，并进行读取和修改</li><li>xxx.properties文件通常是作为配置文件</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Hashtable类&quot;&gt;&lt;a href=&quot;#Hashtable类&quot; class=&quot;headerlink&quot; title=&quot;Hashtable类&quot;&gt;&lt;/a&gt;Hashtable类&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;存放的元素是键值对：K-V&lt;/li&gt;
&lt;li&gt;hashtable</summary>
      
    
    
    
    <category term="技术 学习 java 集合" scheme="https://dwhboke.com/categories/%E6%8A%80%E6%9C%AF-%E5%AD%A6%E4%B9%A0-java-%E9%9B%86%E5%90%88/"/>
    
    
    <category term="技术 操作 学习 Map集合" scheme="https://dwhboke.com/tags/%E6%8A%80%E6%9C%AF-%E6%93%8D%E4%BD%9C-%E5%AD%A6%E4%B9%A0-Map%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Map接口实现类的特点</title>
    <link href="https://dwhboke.com/posts/13.html"/>
    <id>https://dwhboke.com/posts/13.html</id>
    <published>2022-04-23T03:05:00.000Z</published>
    <updated>2022-04-23T03:20:57.315Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Map接口实现类的特点（JDK8）"><a href="#Map接口实现类的特点（JDK8）" class="headerlink" title="Map接口实现类的特点（JDK8）"></a>Map接口实现类的特点（JDK8）</h3><ol><li><code>Map</code>与<code>Collection</code>并列存在，用于保存具有映射关系的数据：<code>Key-Value</code>（双列元素）</li><li><code>Map</code>中的<code>Key</code>和<code>value</code>可以是任何引用类型的数据，会封装到<code>HashMap$Node</code>对象中</li><li>Map中的Key不能重复，否则会替换</li><li>Map中的value可以重复</li><li>Map中Key和value都可以为Null，但是Key只能有一个Null（不可重复）,value可以有多个Null</li><li>常用String作为Map的key</li><li>Key和value之间存在单向一对一的关系，即通过指定的key总能找到对应的value</li><li>Map存放数据，一对k-v是放在一个HashMap$Node中的，因为Node实现了Entry接口，把k-v包装成一个entry存放在EntrySet集合中方便管理</li></ol><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><pre class="line-numbers language-none"><code class="language-none">map.put();map.clear();map.equals();map.get();map.set();map.keySet();map.values();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><ol><li><p>用keySet遍历</p><pre class="line-numbers language-none"><code class="language-none">for (Object obj:keySet){            System.out.println(obj +"-"+ map.get(obj));        }        System.out.println("=====================");        Iterator iterator = keySet.iterator();        while(iterator.hasNext()){            Object obj = iterator.next();            System.out.println(obj+"-"+map.get(obj));        }        System.out.println("=====================");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>用value遍历</p><pre class="line-numbers language-none"><code class="language-none">Collection values = map.values();        //增强for        for (Object obj : values){            System.out.println(obj);        }        System.out.println("===============迭代器================");        Iterator iterator1 = values.iterator();        while (iterator1.hasNext()){            System.out.println(iterator1.next());        }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>用EntrySet遍历</p><pre class="line-numbers language-none"><code class="language-none">Set entrySet = map.entrySet();        //增强for        for (Object obj : entrySet){            Map.Entry e = (Map.Entry) obj;            System.out.println(e.getKey()+"-"+e.getValue());        }        System.out.println("====================");        //EntrySet迭代器        Iterator iterator2 = entrySet.iterator();        while (iterator2.hasNext()){            Object next = iterator2.next();            Map.Entry m = (Map.Entry) next;            //System.out.println(next);            System.out.println(m.getKey()+"-"+m.getValue());        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol><li>Map接口的常用实现类：HashMap、Hashtable和Properties</li><li>HashMap是Map接口使用频率最高的实现类</li><li>HashMap是以key-val对的形式来存储数据</li><li>Key不能重复，但是值可以重复，允许使用null键和null值</li><li>如果添加相同的Key，则会覆盖原来的key-val，等同于修改。（key不会替换，value会替换）</li><li>与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来存储的</li><li>HashMap没有实现同步，因此是线程不安全的</li><li>注：集合与映射资料（非本博客）     <a href="https://blog.csdn.net/weixin_59966683/article/details/119482419">https://blog.csdn.net/weixin_59966683/article/details/119482419</a> </li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Map接口实现类的特点（JDK8）&quot;&gt;&lt;a href=&quot;#Map接口实现类的特点（JDK8）&quot; class=&quot;headerlink&quot; title=&quot;Map接口实现类的特点（JDK8）&quot;&gt;&lt;/a&gt;Map接口实现类的特点（JDK8）&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;cod</summary>
      
    
    
    
    <category term="技术 学习 java 集合" scheme="https://dwhboke.com/categories/%E6%8A%80%E6%9C%AF-%E5%AD%A6%E4%B9%A0-java-%E9%9B%86%E5%90%88/"/>
    
    
    <category term="技术 操作 学习 Map集合" scheme="https://dwhboke.com/tags/%E6%8A%80%E6%9C%AF-%E6%93%8D%E4%BD%9C-%E5%AD%A6%E4%B9%A0-Map%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Set接口的实现类</title>
    <link href="https://dwhboke.com/posts/12.html"/>
    <id>https://dwhboke.com/posts/12.html</id>
    <published>2022-04-23T03:03:00.000Z</published>
    <updated>2022-04-23T03:04:48.494Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Set接口实现类"><a href="#Set接口实现类" class="headerlink" title="Set接口实现类"></a>Set接口实现类</h2><h3 id="Set特性："><a href="#Set特性：" class="headerlink" title="Set特性："></a>Set特性：</h3><ol><li><p><code>HashSet</code>实现了Set接口</p></li><li><p><code>HashSet</code>实际上就是<code>HashMap</code></p><pre class="line-numbers language-none"><code class="language-none">public HashSet(){map = new HashMap&lt;&gt;();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>可以存放null，但是只能有一个</p></li><li><p>HashSet不保证元素是有序的，取决于hash后，再确定索引的结果</p></li><li><p>不能有重复的元素，但是可以存放两个同名的不同对象，如下都能加入到set中。</p><pre class="line-numbers language-none"><code class="language-none">set.add(new Dog("Tom"));set.add(new Dog("Tom"));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h3 id="Set一个经典面试题"><a href="#Set一个经典面试题" class="headerlink" title="Set一个经典面试题"></a>Set一个经典面试题</h3><pre class="line-numbers language-none"><code class="language-none">set.add(new String("abc"));set.add(new String("abc"));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>只有第一个abc进入了set中</p><h3 id="Set扩容机制"><a href="#Set扩容机制" class="headerlink" title="Set扩容机制"></a>Set扩容机制</h3><ol><li><code>HashSet</code>底层是<code>HashMap</code></li><li>添加一个元素时，先得到hash值-会转成-&gt;索引值</li><li>找到存储数据表table，看到这个索引位置是否已经存放的有元素</li><li>如果有，则调用<code>equals</code>比较，如果相同则放弃添加，如果不同，则添加到最后</li><li>如果没有，直接加入</li><li>在java8中，如果一条链表的元素个数超过<code>TREEIFY_THRESHOLD</code>（默认是8），并且table的大小&gt;=<code>MIN_TREEIFY_CAPACITY</code>（默认64），就会进行树化（红黑树）</li></ol><h3 id="Set添加元素实现"><a href="#Set添加元素实现" class="headerlink" title="Set添加元素实现"></a>Set添加元素实现</h3><ol><li>先获取元素的哈希值（hashCode方法）</li><li>对哈希值进行运算，得出一个索引值即为要存放在哈希表中的位置号</li><li>如果该位置上没有其他元素，则直接存放，如果位置上已经有其他元素则进行equal判断，如果相等，不添加，如果不等，则通过链表的方式添加</li></ol><h3 id="LinkHashSet"><a href="#LinkHashSet" class="headerlink" title="LinkHashSet"></a>LinkHashSet</h3><ol><li>LinkedHashSet加入顺序和取出元素/数据的顺序是一致的（有序）</li><li>LinkedHashSet底层维护的是一个LinkedHashMap（是HashMap的子类）</li><li>LinkedHashSet底层结构（数组table+双向链表）</li><li>添加第一次时，直接将数组table扩容到16，存放的结点类型是 LinkedHashMa$Entry</li><li>数组是HashMap$Node</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Set接口实现类&quot;&gt;&lt;a href=&quot;#Set接口实现类&quot; class=&quot;headerlink&quot; title=&quot;Set接口实现类&quot;&gt;&lt;/a&gt;Set接口实现类&lt;/h2&gt;&lt;h3 id=&quot;Set特性：&quot;&gt;&lt;a href=&quot;#Set特性：&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="技术 学习 java 集合" scheme="https://dwhboke.com/categories/%E6%8A%80%E6%9C%AF-%E5%AD%A6%E4%B9%A0-java-%E9%9B%86%E5%90%88/"/>
    
    
    <category term="技术 操作 学习 Set集合" scheme="https://dwhboke.com/tags/%E6%8A%80%E6%9C%AF-%E6%93%8D%E4%BD%9C-%E5%AD%A6%E4%B9%A0-Set%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>构造器传入对象简析</title>
    <link href="https://dwhboke.com/posts/11.html"/>
    <id>https://dwhboke.com/posts/11.html</id>
    <published>2022-04-23T02:55:00.000Z</published>
    <updated>2022-04-23T02:56:13.030Z</updated>
    
    <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">class A {  public void funA() {    System.out.println("haha");  }}class B {  private A a;  B(A a) {    this.a = a;  }  //A a = new A();  public void funB() {    a.funA();  }}class Test02 {  public static void main(String[] args) {    A a = new A();    B b = new B(a);    //B a = new B();    b.funB();  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种用法或者模式叫做<strong>代理模式</strong> </p><p>为什么需要代理模式呢？</p><p>打个比方，假设你的 class A的那个方法funcA的功能是购物；通常情况下，你要去购物肯定可以亲自去商场买，这就是你所说的“直接new一个A类然后调用方法”。但是！假设你要买的东西国内没有，大部分情况下你不太可能亲自飞到海外去买吧，这时候你可以选择代购；什么意思呢？</p><p>可以新建一个class C extends A，然后重写funcA方法，这个方法可以帮你去海外购物；于是使用类B就成了这样子：</p><pre class="line-numbers language-none"><code class="language-none">A c = new C(); // 注意这一行，父类A持有了子类的实现！B b = new B(c);b.funcB();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;pre class=&quot;line-numbers language-none&quot;&gt;&lt;code class=&quot;language-none&quot;&gt;class A {
  public void funA() {
    System.out.println(&quot;haha&quot;);
  }
}

</summary>
      
    
    
    
    <category term="技术 学习 java" scheme="https://dwhboke.com/categories/%E6%8A%80%E6%9C%AF-%E5%AD%A6%E4%B9%A0-java/"/>
    
    
    <category term="技术 操作 学习 构造器" scheme="https://dwhboke.com/tags/%E6%8A%80%E6%9C%AF-%E6%93%8D%E4%BD%9C-%E5%AD%A6%E4%B9%A0-%E6%9E%84%E9%80%A0%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>打印流</title>
    <link href="https://dwhboke.com/posts/10.html"/>
    <id>https://dwhboke.com/posts/10.html</id>
    <published>2022-04-05T02:36:00.000Z</published>
    <updated>2022-04-05T02:39:43.655Z</updated>
    
    <content type="html"><![CDATA[<h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><p>打印流只有输出流，没有输入流</p><h3 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a>PrintStream</h3><p>该类的关系图：<img src="https://s2.loli.net/2022/04/05/QkrXFtYRz9BUdEy.png"></p><ol><li><p>OutputStream是所有字节流的父类，所有PrintStream也是字节流</p></li><li><p>默认情况下，OutputStream打印的位置是显示器(控制台)。</p></li><li><p>用<code>System.setOut(new PrintStream(“  ”))</code>方法修改打印流输出的位置</p></li><li><p>因为print底层使用的是write方法打印，所以可以直接使用write方法来打印，用print和write打印本质是一样的</p></li><li><p>记得关闭流</p></li></ol><h3 id="PrintWrite"><a href="#PrintWrite" class="headerlink" title="PrintWrite"></a>PrintWrite</h3><p>该类的关系图：</p><p><img src="https://s2.loli.net/2022/04/05/3MxbpyVCJgd7nUY.png"></p><ol><li><p>Write是所有字符流的父类，所以PrintWrite是字符流</p></li><li><p>改变打印的位置</p><pre class="line-numbers language-none"><code class="language-none">PrintWriter printWriter = new PrintWriter(new FileWriter("xxxxx"));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>记得关闭流，否则不会进到文件</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;打印流&quot;&gt;&lt;a href=&quot;#打印流&quot; class=&quot;headerlink&quot; title=&quot;打印流&quot;&gt;&lt;/a&gt;打印流&lt;/h2&gt;&lt;p&gt;打印流只有输出流，没有输入流&lt;/p&gt;
&lt;h3 id=&quot;PrintStream&quot;&gt;&lt;a href=&quot;#PrintStream&quot; cla</summary>
      
    
    
    
    <category term="技术 学习 java" scheme="https://dwhboke.com/categories/%E6%8A%80%E6%9C%AF-%E5%AD%A6%E4%B9%A0-java/"/>
    
    
    <category term="技术 操作 学习 java流" scheme="https://dwhboke.com/tags/%E6%8A%80%E6%9C%AF-%E6%93%8D%E4%BD%9C-%E5%AD%A6%E4%B9%A0-java%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>Java流</title>
    <link href="https://dwhboke.com/posts/9.html"/>
    <id>https://dwhboke.com/posts/9.html</id>
    <published>2022-04-03T02:30:00.000Z</published>
    <updated>2022-04-03T02:31:19.630Z</updated>
    
    <content type="html"><![CDATA[<h2 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h2><h3 id="节点流和处理流的区别和联系"><a href="#节点流和处理流的区别和联系" class="headerlink" title="节点流和处理流的区别和联系"></a>节点流和处理流的区别和联系</h3><ol><li>节点流是底层流，直接和数据源相连接</li><li>处理流包装节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出</li><li>处理流对节点流进行包装，使用了修饰器设计模式，不会直接与数据源相连</li></ol><h3 id="处理流的功能主要体现"><a href="#处理流的功能主要体现" class="headerlink" title="处理流的功能主要体现"></a>处理流的功能主要体现</h3><ol><li>性能的提高：主要以增加缓冲的方式提高输入输出的效率</li><li>操作的便捷：处理流可能提供了一系列便捷的方法来一次输入输出大批量的数据，使用更加方便灵活</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;节点流和处理流&quot;&gt;&lt;a href=&quot;#节点流和处理流&quot; class=&quot;headerlink&quot; title=&quot;节点流和处理流&quot;&gt;&lt;/a&gt;节点流和处理流&lt;/h2&gt;&lt;h3 id=&quot;节点流和处理流的区别和联系&quot;&gt;&lt;a href=&quot;#节点流和处理流的区别和联系&quot; class</summary>
      
    
    
    
    <category term="技术 学习 java" scheme="https://dwhboke.com/categories/%E6%8A%80%E6%9C%AF-%E5%AD%A6%E4%B9%A0-java/"/>
    
    
    <category term="技术 操作 学习 java流" scheme="https://dwhboke.com/tags/%E6%8A%80%E6%9C%AF-%E6%93%8D%E4%BD%9C-%E5%AD%A6%E4%B9%A0-java%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>Java内部类</title>
    <link href="https://dwhboke.com/posts/8.html"/>
    <id>https://dwhboke.com/posts/8.html</id>
    <published>2022-03-24T03:14:00.000Z</published>
    <updated>2022-03-24T03:18:45.652Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h4 id="内部类简介"><a href="#内部类简介" class="headerlink" title="内部类简介"></a>内部类简介</h4><p>一个类里面包含了一个类结构，这个内部类可以直接访问私有属性，内部类是类的第五大成员（属性、方法、构造器、代码块、内部类）</p><h4 id="内部类的使用"><a href="#内部类的使用" class="headerlink" title="内部类的使用"></a>内部类的使用</h4><p>某个接口或者一个抽象方法只需要用一次的时候，就可以用到内部类。</p><p>使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。——《Think in java》<br>也就是说内部类拥有类的基本特征。(可以继承父类，实现接口)在实际问题中我们会遇到一些接口无法解决或难以解决的问题，此时我们可以使用内部类继承某个具体的或抽象的类，间接解决类无法多继承引起的一系列问题。</p><p>（注：内部类可以嵌套内部类，但是这极大的破坏了代码的结构，不推荐使用。）</p><h4 id="内部类的优点"><a href="#内部类的优点" class="headerlink" title="内部类的优点"></a>内部类的优点</h4><ol><li>内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立</li><li>内部类并没有令人迷惑的<code>“is-a”</code>关系，他就是一个独立的实体。</li><li>内部类提供了更好的封装，除了该外围类，其他类都不能访问。</li><li>创建内部类对象的时刻并不依赖于外围类对象的创建。<br>具体来说，内部类信息（属性、方法）可以和外部类重名；内部类是具有类的基本特征的独立实体；可以利用访问修饰符隐藏内部类的实施细节，提供了更好的封装；静态内部类使用时可直接使用，不需先创造外部类。</li></ol><h3 id="内部类分类"><a href="#内部类分类" class="headerlink" title="内部类分类"></a>内部类分类</h3><p>定义在外部类局部位置上（方法里）：</p><ol><li>局部内部类（有类名）</li><li>匿名内部类（无类名）</li></ol><p>定义在外部类的成员位置上：</p><ol><li>成员内部类（没用static修饰）</li><li>静态内部类（使用static修饰）</li></ol><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>定义在外部类的局部位置，有类名。</p><ol><li><p>可以直接访问外部类的所有成员，包括私有的</p></li><li><p>不能添加访问修饰符，因为它的位置是一个局部变量，局部变量不能用修饰符的，但是可以用final修饰，因为局部变量也可以用final。</p></li><li><p>作用域：仅仅在定义它的方法或者代码块里。</p></li><li><p>局部内部类访问直接访问外部类的成员</p></li><li><p>外部类访问局部内部类，要先创建对象（在外部类里创建内部类的对象，在<code>main</code>方法创建外部类对象，用外部类对象调用内部类的代码块或者定义它的方法），再访问，而且必须在作用域内。</p></li><li><p>外部其他类不能访问局部内部类（因为局部内部类地位是一个局部变量）</p></li><li><p>如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想要访问外部类的成员，可以使用（外部类名.this.成员）去访问</p><pre class="line-numbers language-none"><code class="language-none">System.out.println("外部类的n2=" + 外部类名.this.n2);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><ol><li>匿名内部类申明的地点和局部内部类一样，都是在方法或者代码块中，地位都等价于局部变量，因此在局部内部类中的限制在匿名内部类中一样适用</li><li>匿名内部类也可以直接访问外部类的所有成员，包括私有的</li><li>不能添加任何的访问修饰符</li><li>作用域：在整个方法或者代码块</li><li>可以直接访问外部类的成员</li><li>外部类访问匿名内部类，要先创建对象（在外部类里创建内部类的对象，在<code>main</code>方法创建外部类对象，用外部类对象调用内部类的代码块或者定义它的方法），再访问，而且必须在作用域内。</li><li>外部其他类不能访问局部内部类（因为局部内部类地位是一个局部变量）</li><li>如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想要访问外部类的成员，可以使用（外部类名.this.成员）去访问</li></ol><h5 id="匿名内部类的使用"><a href="#匿名内部类的使用" class="headerlink" title="匿名内部类的使用"></a>匿名内部类的使用</h5><ol><li><p>被当做实参，直接传递</p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) {f1(new IL(){public void show(){System.out.println("xxx");}});}public static void f1(IL il){il.show();}interface IL{public void show();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><ol><li><p>可以用任何的修饰符</p></li><li><p>内部类的内部不能有静态信息</p></li><li><p>内部类也是类，可以继承，可重写，可以重载，<code>this</code> 和 <code>super</code> 可以使用。</p></li><li><p>内部类可以直接使用外部类的任何信息</p></li><li><p>其它类如何访问内部类：</p><pre class="line-numbers language-none"><code class="language-none">Outer outer = new Outer();//创造内部类对象Outer.Inner inner = outer.new Inner();inner.innerShow();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>成员内部类认为是外部类的成员信息。</p></li></ol><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>静态内部类是内部类中一个比较特殊的情况，<code>Java</code> 文档中是这样描述静态内部类的：一旦内部类使用 <code>static</code> 修饰，那么此时这个内部类就升级为顶级类。<br>也就是说，除了写在一个类的内部以外，静态内部类具备所有外部类的特性。</p><ol><li>静态内部类也是定义在外部类的成员位置上，而且有<code>static</code>修饰。</li><li>可以直接访问外部类所有的静态成员，包括私有的，但是不能访问非静态成员。</li><li>可以添加任何的修饰符。</li><li>作用域：和成员内部类一样，作用整个类体</li><li>静态内部类访问外部类静态成员：直接用</li><li>外部类访问静态内部类：创建对象，再访问</li><li>其他类访问静态内部类：利用 外部类.内部类 引用 = new 外部类.内部类(); 然后利用 引用.成员信息(属性、方法) 调用。</li><li>外部类和内部类成员同名，遵循就近原则，如要访问外部类成员，则使用（外部类.成员）访问。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;内部类&quot;&gt;&lt;a href=&quot;#内部类&quot; class=&quot;headerlink&quot; title=&quot;内部类&quot;&gt;&lt;/a&gt;内部类&lt;/h2&gt;&lt;h4 id=&quot;内部类简介&quot;&gt;&lt;a href=&quot;#内部类简介&quot; class=&quot;headerlink&quot; title=&quot;内部类简介&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="技术 学习 java" scheme="https://dwhboke.com/categories/%E6%8A%80%E6%9C%AF-%E5%AD%A6%E4%B9%A0-java/"/>
    
    
    <category term="技术 操作 学习 java内部类" scheme="https://dwhboke.com/tags/%E6%8A%80%E6%9C%AF-%E6%93%8D%E4%BD%9C-%E5%AD%A6%E4%B9%A0-java%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java方法的调用</title>
    <link href="https://dwhboke.com/posts/7.html"/>
    <id>https://dwhboke.com/posts/7.html</id>
    <published>2022-03-20T13:37:00.000Z</published>
    <updated>2022-03-20T13:41:51.762Z</updated>
    
    <content type="html"><![CDATA[<h3 id="方法调用的细节"><a href="#方法调用的细节" class="headerlink" title="方法调用的细节"></a>方法调用的细节</h3><h4 id="同类中方法对方法的调用"><a href="#同类中方法对方法的调用" class="headerlink" title="同类中方法对方法的调用"></a>同类中方法对方法的调用</h4><p>同类中非静态方法调用同类的其他方法，可以直接方法名调用</p><p>静态方法不能访问非静态成员（变量和方法）</p><h4 id="不同类之间方法的调用"><a href="#不同类之间方法的调用" class="headerlink" title="不同类之间方法的调用"></a>不同类之间方法的调用</h4><p>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。</p><p>实例方法只有“对象名.方法名”这种方式。也就是说，调用静态方法可以无需创建对象。（即创建需要调用的方法的类的对象，然后用对象调用）</p><pre class="line-numbers language-none"><code class="language-none">class A{  public void pa(){}}class B{A a1 = new A(); public void b(){  a.pa(); }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="传参机制"><a href="#传参机制" class="headerlink" title="传参机制"></a>传参机制</h4><p>java中，基本数据类型传参，是按值拷贝，形参不会影响实参。</p><p>引用类型传参是按照地址传参，形参会影响实参。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;方法调用的细节&quot;&gt;&lt;a href=&quot;#方法调用的细节&quot; class=&quot;headerlink&quot; title=&quot;方法调用的细节&quot;&gt;&lt;/a&gt;方法调用的细节&lt;/h3&gt;&lt;h4 id=&quot;同类中方法对方法的调用&quot;&gt;&lt;a href=&quot;#同类中方法对方法的调用&quot; class=&quot;he</summary>
      
    
    
    
    <category term="技术 学习 java" scheme="https://dwhboke.com/categories/%E6%8A%80%E6%9C%AF-%E5%AD%A6%E4%B9%A0-java/"/>
    
    
    <category term="技术 操作 学习 javaI方法" scheme="https://dwhboke.com/tags/%E6%8A%80%E6%9C%AF-%E6%93%8D%E4%BD%9C-%E5%AD%A6%E4%B9%A0-javaI%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JavaIO流入门</title>
    <link href="https://dwhboke.com/posts/6.html"/>
    <id>https://dwhboke.com/posts/6.html</id>
    <published>2022-03-09T13:00:00.000Z</published>
    <updated>2022-03-09T12:56:27.497Z</updated>
    
    <content type="html"><![CDATA[<h3 id="IO流（文件）"><a href="#IO流（文件）" class="headerlink" title="IO流（文件）"></a>IO流（文件）</h3><h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>文件是保存数据的地方</p><h4 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h4><p>文件在程序中是以流的形式来操作的</p><p><img src="https://s2.loli.net/2022/03/09/fE3TOhRjoBI6kCc.png"></p><p>流：数据在数据源(文件)和程序(内存)直接经历的路径</p><p>输入流：数据从数据源(文件)到程序(内存)的路径</p><p>输出流：数据从程序(内存)到数据源(文件)的路径</p><h4 id="常用的文件操作"><a href="#常用的文件操作" class="headerlink" title="常用的文件操作"></a>常用的文件操作</h4><p>创建文件对象相关构造器和方法</p><p>相关方法：</p><pre class="line-numbers language-none"><code class="language-none">new File(String pathname)//根据路径构建一个File对象new File(File parent,String child)//根据父目录文件+子路径构建new File(String parent,String child)//根据父目录+子路径构建createNewFile //创建新文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>获取文件的相关信息</p><ol><li>获取文件名字：<code>file.getName()</code></li><li>获取文件绝对路径：<code>file.getAbsolutePath()</code></li><li>获取文件父目录：<code>file.getParent()</code></li><li>文件大小(按字节统计)：<code>file.length()</code></li><li>判断文件是否存在：<code>file.exists()</code></li><li>判断是否是一个文件：<code>file.isFile()</code></li><li>判断是否是一个目录：<code>file.isDirectory()</code></li></ol><h4 id="目录的操作和文件的删除"><a href="#目录的操作和文件的删除" class="headerlink" title="目录的操作和文件的删除"></a>目录的操作和文件的删除</h4><p>创建一级目录：<code>mkdir()</code></p><p>创建多级目录：<code>mkdirs()</code></p><p>删除空目录或者文件：<code>delete()</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;IO流（文件）&quot;&gt;&lt;a href=&quot;#IO流（文件）&quot; class=&quot;headerlink&quot; title=&quot;IO流（文件）&quot;&gt;&lt;/a&gt;IO流（文件）&lt;/h3&gt;&lt;h4 id=&quot;文件&quot;&gt;&lt;a href=&quot;#文件&quot; class=&quot;headerlink&quot; title=&quot;文</summary>
      
    
    
    
    <category term="技术 学习 java" scheme="https://dwhboke.com/categories/%E6%8A%80%E6%9C%AF-%E5%AD%A6%E4%B9%A0-java/"/>
    
    
    <category term="技术 操作 学习 javaIO流" scheme="https://dwhboke.com/tags/%E6%8A%80%E6%9C%AF-%E6%93%8D%E4%BD%9C-%E5%AD%A6%E4%B9%A0-javaIO%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>Java泛型入门</title>
    <link href="https://dwhboke.com/posts/5.html"/>
    <id>https://dwhboke.com/posts/5.html</id>
    <published>2022-03-07T13:58:00.000Z</published>
    <updated>2022-03-07T14:13:11.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="泛型的理解和好处"><a href="#泛型的理解和好处" class="headerlink" title="泛型的理解和好处"></a>泛型的理解和好处</h2><ol><li>编译时，检查添加元素的类型，提高了安全性</li><li>减少了类型转换次数，提高了效率</li><li>不再提示编译警告</li></ol><h2 id="泛型介绍"><a href="#泛型介绍" class="headerlink" title="泛型介绍"></a>泛型介绍</h2><p>泛（广泛）型（类型）=&gt;<code>Integer,String,Dog</code></p><ol><li>泛型又叫参数化类型，是<code>jdk5.0</code>出现的新特性，解决数据类型的安全性问题。</li><li>在类声明或实例化时只要制定好需要的具体类型即可。</li><li>JAVA泛型可以保证如果程序在编译时没有警告，运行时就不会产生<code>ClassCastException</code>异常，同时，代码更加简洁。</li><li>泛型的作用是：可以在声明类时通过一个标识表示类中的某一个属性的类型，或者是某个方法的返回值的类型，或者是参数类型。</li></ol><h2 id="泛型的语法"><a href="#泛型的语法" class="headerlink" title="泛型的语法"></a>泛型的语法</h2><h3 id="泛型的声明"><a href="#泛型的声明" class="headerlink" title="泛型的声明"></a>泛型的声明</h3><p>其中，T,K,V不代表值，而是表示类型</p><p>任何字母都可以。</p><pre class="line-numbers language-none"><code class="language-none">interface 接口&lt;T&gt;{}interface 接口&lt;T,V&gt;{}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="泛型的实例化"><a href="#泛型的实例化" class="headerlink" title="泛型的实例化"></a>泛型的实例化</h3><p>要在类名后面指定类型参数的值。例如：</p><pre class="line-numbers language-none"><code class="language-none">List&lt;String&gt; strList = new ArrayList&lt;String&gt;();Iterator&lt;Customer&gt; iterator = customers.iterator();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="泛型使用的细节"><a href="#泛型使用的细节" class="headerlink" title="泛型使用的细节"></a>泛型使用的细节</h2><ol><li><p>注意泛型使用的时候是加入引用类型不是数据类型，比如，加入<code>Integer</code>是正确的，加入<code>int</code>就错误。</p></li><li><p>在指定泛型具体类型后，可以传入该类型或者子类类型</p></li><li><p>泛型使用形式</p><pre class="line-numbers language-none"><code class="language-none">List&lt;Integer&gt;list1 = new ArrayList&lt;Integer&gt;();List&lt;Integer&gt;list2 = new ArrayList&lt;&gt;();[说明：]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>如果我们这样写 <code>List list3 = new ArrayList();</code> 默认给它的泛型是<code>&lt;E&gt; E就是Object</code>。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;泛型的理解和好处&quot;&gt;&lt;a href=&quot;#泛型的理解和好处&quot; class=&quot;headerlink&quot; title=&quot;泛型的理解和好处&quot;&gt;&lt;/a&gt;泛型的理解和好处&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;编译时，检查添加元素的类型，提高了安全性&lt;/li&gt;
&lt;li&gt;减少了类型转换次数，</summary>
      
    
    
    
    <category term="技术 学习 java" scheme="https://dwhboke.com/categories/%E6%8A%80%E6%9C%AF-%E5%AD%A6%E4%B9%A0-java/"/>
    
    
    <category term="技术 操作 学习 java泛型" scheme="https://dwhboke.com/tags/%E6%8A%80%E6%9C%AF-%E6%93%8D%E4%BD%9C-%E5%AD%A6%E4%B9%A0-java%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>集合的基础体系</title>
    <link href="https://dwhboke.com/posts/4.html"/>
    <id>https://dwhboke.com/posts/4.html</id>
    <published>2022-03-06T06:54:00.000Z</published>
    <updated>2022-04-23T03:12:44.706Z</updated>
    
    <content type="html"><![CDATA[<h3 id="集合框架体系图"><a href="#集合框架体系图" class="headerlink" title="集合框架体系图"></a>集合框架体系图</h3><h4 id="单列集合"><a href="#单列集合" class="headerlink" title="单列集合"></a>单列集合</h4><p><img src="https://s2.loli.net/2022/03/06/J5Cm4nMgj7KLZuE.png"></p><h4 id="双列集合"><a href="#双列集合" class="headerlink" title="双列集合"></a>双列集合</h4><p><img src="https://s2.loli.net/2022/03/06/E2GxDNSkstVJ86j.png"></p><h3 id="集合的优点"><a href="#集合的优点" class="headerlink" title="集合的优点"></a>集合的优点</h3><ol><li>可以<strong>动态保存</strong>任意的多个对象，使用很方便</li><li>提供了一系列方便的操作对象的方法：add、remove、set、get等等</li><li>使用集合进行添加，删除新元素的示意代码简洁明了</li></ol><h3 id="集合简单的使用"><a href="#集合简单的使用" class="headerlink" title="集合简单的使用"></a>集合简单的使用</h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>一次放一个数据所以叫单列集合</p><pre class="line-numbers language-none"><code class="language-none">ArrayList arrayList = new ArrayList();arrayList.add("jake");arrayList.add("tom");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>一次放两个数据所以叫双列集合</p><pre class="line-numbers language-none"><code class="language-none">HashMap hashMap = new HashMap();hashMap.put("NO1","北京");hashMap.put("NO2","上海");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="Collection接口和常用方法"><a href="#Collection接口和常用方法" class="headerlink" title="Collection接口和常用方法"></a>Collection接口和常用方法</h3><h4 id="collection接口实现类的特点"><a href="#collection接口实现类的特点" class="headerlink" title="collection接口实现类的特点"></a>collection接口实现类的特点</h4><pre class="line-numbers language-none"><code class="language-none">public interface Collection&lt;E&gt; extends lterable&lt;E&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li><code>collection</code>实现子类可以存放多个元素，每个元素可以是Object</li><li>有些<code>Collection</code>的实现类，可以存放重复的元素，有些不可以</li><li>有些<code>Collection</code>的实现类，有些是有序的(List)，有些不是有序的(Set)</li><li><code>Collection</code>接口没有直接的实现子类，是通过它的子接口<code>Set</code>和<code>List</code>来实现的</li></ol><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ol><li><code>add</code>：添加单个元素</li><li><code>remove</code>：删除指定元素</li><li><code>contains</code>：查找元素是否存在</li><li><code>size</code>：获取元素个数</li><li><code>isEmpty</code>：判断是否为空</li><li><code>clear</code>：清空</li><li><code>addAll</code>：添加多个元素</li><li><code>containsAll</code>：查找多个元素是否都存在</li><li><code>removeAll</code>：删除多个元素</li></ol><h3 id="Vector和ArrayList的比较"><a href="#Vector和ArrayList的比较" class="headerlink" title="Vector和ArrayList的比较"></a>Vector和ArrayList的比较</h3><p><img src="https://s2.loli.net/2022/04/09/HDCExkgSdnGTp4J.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;集合框架体系图&quot;&gt;&lt;a href=&quot;#集合框架体系图&quot; class=&quot;headerlink&quot; title=&quot;集合框架体系图&quot;&gt;&lt;/a&gt;集合框架体系图&lt;/h3&gt;&lt;h4 id=&quot;单列集合&quot;&gt;&lt;a href=&quot;#单列集合&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="技术 学习 java 集合" scheme="https://dwhboke.com/categories/%E6%8A%80%E6%9C%AF-%E5%AD%A6%E4%B9%A0-java-%E9%9B%86%E5%90%88/"/>
    
    
    <category term="技术 操作 学习 java集合" scheme="https://dwhboke.com/tags/%E6%8A%80%E6%9C%AF-%E6%93%8D%E4%BD%9C-%E5%AD%A6%E4%B9%A0-java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>如何在GitHub上搭建hexo博客</title>
    <link href="https://dwhboke.com/posts/3.html"/>
    <id>https://dwhboke.com/posts/3.html</id>
    <published>2022-03-05T10:39:00.000Z</published>
    <updated>2022-03-06T04:02:28.897Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这是一篇关于如何搭建 hexo 博客的文章。</p><h2 id="一、大致所需要用到的工具或者网站"><a href="#一、大致所需要用到的工具或者网站" class="headerlink" title="一、大致所需要用到的工具或者网站"></a>一、大致所需要用到的工具或者网站</h2><ol><li>GitHub</li><li>Git Bash</li><li>HEXO</li></ol><h2 id="二、主要步骤"><a href="#二、主要步骤" class="headerlink" title="二、主要步骤"></a>二、主要步骤</h2><ol><li>配置好上述工具</li><li>创建一个 GitHub 仓库</li><li>GitHub 上生成 SSH Keys</li><li>生成本地</li><li>发布到互联网上</li></ol><h2 id="三、具体操作"><a href="#三、具体操作" class="headerlink" title="三、具体操作"></a>三、具体操作</h2><h3 id="1-安装Git-和-HEXO"><a href="#1-安装Git-和-HEXO" class="headerlink" title="1. 安装Git 和 HEXO"></a>1. 安装Git 和 HEXO</h3><p>这个东西直接去官方网站下载就行了。<a href="https://git-scm.com/">Git 官网</a> <a href="https://hexo.io/zh-cn/">HEXO官网</a></p><h3 id="2-创建一个GitHub-仓库"><a href="#2-创建一个GitHub-仓库" class="headerlink" title="2. 创建一个GitHub 仓库"></a>2. 创建一个GitHub 仓库</h3><p>在注册好GitHub账号之后，然后去创建一个新的仓库(点击此处的<code>New</code>)</p><p><img src="https://s2.loli.net/2022/03/05/ufapyQUNXJ7CzIh.png"></p><p>然后此处的<code>Repository name</code>和你的<code>Owne</code>r要一样(比如，我的<code>owner</code>是dgithubq,那么<code>name</code>就填dgithubq.github.io)。页面其他的选项默认即可。</p><p><img src="https://s2.loli.net/2022/03/05/oY1fNxZgEMJ6mwp.png"></p><p>然后<code>Add a README file</code>需要勾选上。</p><p>到此，点击创建之后，那么你的存储库就已经建成功了，你的博客网址就是你刚才的Repository name。</p><h3 id="3-生成一个SSH-Keys"><a href="#3-生成一个SSH-Keys" class="headerlink" title="3. 生成一个SSH Keys"></a>3. 生成一个SSH Keys</h3><p>这个东西很重要，因为后面上传到网络上面去的时候需要它，所以这一步要仔细一点。但是也不会特别的难。</p><p>首先：我们在桌面上进入任何一个文件夹，然后打开下载好的Git Bash，然后我们需要敲打以下的命令来检查ssh是否安装，默认一般是已经安装了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后敲打第二个命令来生成SSH Keys（引号中填自己的邮箱）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen -t rsa -C <span class="token string">"xxx@xxx.xxx"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时会在我们的文件夹中建立一个ssh，一般会存放在<code>C:\用户\Administrator\.ssh</code>中。</p><p>找到文件夹之后，打开其中的id_rsa.pub文件，完全复制其中的内容，然后再去打开GitHub。</p><p>在个人设置中找到这个地方：</p><p><img src="https://s2.loli.net/2022/03/05/c1yMPDjgQO5J4wp.png"></p><p>在里面New SSH key，然后会看到以下需要填的内容：</p><p> <img src="https://s2.loli.net/2022/03/05/zGSFwEV7UThADBQ.png"></p><p>Title中随便取，无所谓，key中填入刚才<code>.pub</code>文件里复制的内容，然后在git bash中输入以下命令测试是否绑定成功即可：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> -T git@github.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-生成本地博客"><a href="#4-生成本地博客" class="headerlink" title="4. 生成本地博客"></a>4. 生成本地博客</h3><p>去一个自己喜欢的地方建一个文件夹，然后在此文件夹中打开git bash,然后开始敲命令：</p><p>(1) 初始化hexo</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果没有出现 INFO Start blogging with Hexo！ 就说明有问题，重新执行上面的命令即可，成功之后，刚才的文件夹中会多出很多文件，比如：</p><p><img src="https://s2.loli.net/2022/03/05/owY23BOdip7jq8W.png"></p><p>(2) 静态生成hexo本地页面</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>成功后会出现一个Http://xxx的网址，可以去网页中打开，这就是同志们博客的本地生成的页面。</p><h3 id="5-将博客发布到互联网上"><a href="#5-将博客发布到互联网上" class="headerlink" title="5. 将博客发布到互联网上"></a>5. 将博客发布到互联网上</h3><p>(1) 在上一步中生成的文件中，打开_config.yml文件，修改deploy中的东西，一般在最下面。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">deploy:type: <span class="token function">git</span>repository: https://github.com/XXX/XXX.github.io.gitbranch: main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>(2)在你的博客文件下打开git bash输入以下命令，这是安装hexo-deployer-git自动部署工具</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成页面</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上传到GitHub仓库(很多人第一次上传，由于GitHub是一个国外的服务器，所以第一次会非常难成功，如果没有弹出输入GitHub账号的弹窗，请多试验几次，总会成功的，博主命不好，试了很多次才成功，总之坚持就是胜利！)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>出现这个就是成功了：</p><p><img src="https://s2.loli.net/2022/03/05/Kb6NrcswUgy31u5.png"></p><p>这第一个弹窗是输入用户名，下面还有一个弹窗需要注意了！！！</p><p><img src="https://s2.loli.net/2022/03/05/PZ3DCt4bFgI1GzY.png"></p><p>出现这个弹窗之后，要去到GitHub中个人设置里找到Developer setting开发者设置中创建一个令牌，随便取一个名字，权限为了减少麻烦，建议全选，然后把出现的序列号填入第二个弹窗中。(千万不要直接输入GitHub的密码，可能会导致错误，一旦错误，以上步骤又要重来)</p><p>上传成功之后，你的博客就传到互联网上了，你的博客网址就是你的仓库名。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是本人自己创建博客的步骤，个人觉得比较详细，应该不会有太大问题，祝各位好运啦~~~!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;这是一篇关于如何搭建 hexo 博客的文章。&lt;/p&gt;
&lt;h2 id=&quot;一、大致所需要用到的工具或者网站&quot;&gt;&lt;a href=&quot;#一、大致所需要</summary>
      
    
    
    
    <category term="技术 学习" scheme="https://dwhboke.com/categories/%E6%8A%80%E6%9C%AF-%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="技术 操作 想法" scheme="https://dwhboke.com/tags/%E6%8A%80%E6%9C%AF-%E6%93%8D%E4%BD%9C-%E6%83%B3%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>博客与博主</title>
    <link href="https://dwhboke.com/posts/1.html"/>
    <id>https://dwhboke.com/posts/1.html</id>
    <published>2022-03-04T13:00:00.000Z</published>
    <updated>2022-03-06T04:14:59.793Z</updated>
    
    <content type="html"><![CDATA[<p>相遇皆是缘分</p><h3 id="为什么建博客？"><a href="#为什么建博客？" class="headerlink" title="为什么建博客？"></a>为什么建博客？</h3><p>肿么说了! 纯属个人兴趣，好玩，唉，就是玩!嘻嘻! 会有些成就感吧,拥有一个自己的博客写一些自己感兴趣的事或物,不是一件很酷的事嘛!</p><h3 id="展望博客"><a href="#展望博客" class="headerlink" title="展望博客"></a>展望博客</h3><p>我会整理一些个人所学的知识或生活方面有兴趣的事发到博客上供大家观摩</p><h3 id="关于博主"><a href="#关于博主" class="headerlink" title="关于博主"></a>关于博主</h3><p>一位准备放飞理想的有志青年，常年emo，喜欢dyn</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">林深时见鹿，海蓝时见鲸，梦醒时见你<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>溜了溜了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;相遇皆是缘分&lt;/p&gt;
&lt;h3 id=&quot;为什么建博客？&quot;&gt;&lt;a href=&quot;#为什么建博客？&quot; class=&quot;headerlink&quot; title=&quot;为什么建博客？&quot;&gt;&lt;/a&gt;为什么建博客？&lt;/h3&gt;&lt;p&gt;肿么说了! 纯属个人兴趣，好玩，唉，就是玩!嘻嘻! 会有些成就感吧,拥有</summary>
      
    
    
    
    <category term="生活" scheme="https://dwhboke.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="想法" scheme="https://dwhboke.com/tags/%E6%83%B3%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>测试文章</title>
    <link href="https://dwhboke.com/posts/2.html"/>
    <id>https://dwhboke.com/posts/2.html</id>
    <published>2022-03-04T06:00:00.000Z</published>
    <updated>2022-03-21T13:56:20.678Z</updated>
    
    <content type="html"><![CDATA[<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code>本章仅用于测试！！！    --dwh</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;测试&quot;&gt;&lt;a href=&quot;#测试&quot; class=&quot;headerlink&quot; title=&quot;测试&quot;&gt;&lt;/a&gt;测试&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;本章仅用于测试！！！


    --dwh&lt;/code&gt;&lt;/pre&gt;
</summary>
      
    
    
    
    <category term="生活" scheme="https://dwhboke.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="试验" scheme="https://dwhboke.com/tags/%E8%AF%95%E9%AA%8C/"/>
    
  </entry>
  
</feed>
